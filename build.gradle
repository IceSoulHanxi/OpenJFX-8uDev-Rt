/*
 * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/**
 * The main build script for JavaFX.
 *
 * MUST FIX tasks to complete:
 *  - build check -- making sure the final artifact has the right bits
 *      - some things worth automatically sanity checking:
 *          - are there images in the javadocs?
 *          - are all of the expected dylibs etc there?
 *          - is jfxrt.jar there?
 *          - does jfxrt.jar contain stuff it shouldn't (doc-files, iml, etc)
 *          - does jfxrt.jar contain stuff it should (bss files, etc)
 *  - Perform sanity checking to make sure a JDK exists with javac, javah, etc
 *  - Support building with no known JDK location, as long as javac, javah, etc are on the path
 *  - Check all of the native flags. We're adding weight to some libs that don't need it, and so forth.
 *
 * Additional projects to work on as we go:
 *  - Add "developer debug". This is where the natives do not have debug symbols, but the Java code does
 *  - The genVSproperties.bat doesn't find the directory where RC.exe lives. So it is hard coded. Might be a problem.
 *  - special tasks for common needs, such as:
 *      - updating copyright headers
 *      - stripping trailing whitespace (?)
 *  - checkstyle
 *  - findbugs
 *  - re needs?
 *  - sqe testing
 *  - API change check
 *  - Pushing results to a repo?
 *  - ServiceWithSecurityManagerTest fails to complete when run from gradle.
 *  - Integrate Parfait reports for C code
 *  - FXML Project tests are not running
 */
defaultTasks = ["assemble"]

/******************************************************************************
 *                              Utility methods                               *
 *****************************************************************************/

/**
 * If the given named property is not defined, then this method will define
 * it with the given defaultValue. Any properties defined by this method can
 * be substituted on the command line by using -P, or by specifying a
 * gradle.properties file in the user home dir
 *
 * @param name The name of the property to define
 * @param defaultValue The default value to assign the property
 */
void defineProperty(String name, String defaultValue) {
    if (!project.hasProperty(name)) {
        project.ext.set(name, defaultValue);
    }
}

/**
 * If the given named property is not defined, then this method will attempt to
 * look up the property in the props map, and use the defaultValue if it cannot be found.
 *
 * @param name The name of the property to look up and/or define
 * @param props The properties to look for the named property in, if it has not already been defined
 * @param defaultValue The default value if the property has not been defined and the
 *                     props map does not contain the named property
 */
void defineProperty(String name, Properties props, String defaultValue) {
    if (!project.hasProperty(name)) {
        project.ext.set(name, props.getProperty(name, defaultValue));
    }
}

/**
 * Converts the simple name of a library to the full name. For example, on mac
 * the simple name "glass" becomes "libglass.dylib". On Linux or Solaris, it would
 * be "libglass.so", and on Windows "glass.dll".
 *
 * @param name The simple name of the library
 * @return The name of the shared library file
 */
String library(String name) {
    return "${IS_WINDOWS ? '' : 'lib'}$name.${IS_WINDOWS ? 'dll' : IS_MAC ? 'dylib' : 'so'}"
}

String cygpath(String path) {
    if (!IS_WINDOWS) return path;
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    exec {
        standardOutput = out
        commandLine "cmd", "/c", "cygpath", "-m", path
    }
    return out.toString().trim();
}

/******************************************************************************
 *                                                                            *
 *                   Definition of project properties                         *
 *                                                                            *
 *  All properties defined using ext. are immediately available throughout    *
 *  the script as variables that can be used. These variables are attached    *
 *  to the root project (whereas if they were defined as def variables then   *
 *  they would only be available within the root project scope).              *
 *                                                                            *
 *  All properties defined using the "defineProperty" method can be replaced  *
 *  on the command line by using the -P flag. For example, to override the    *
 *  location of the binary plug, you would specify -PBINARY_PLUG=some/where   *
 *                                                                            *
 *****************************************************************************/

// These variables indicate what the platform is that is doing the build. Is
// this build running on a Mac, Windows, or Linux machine? 32 or 64 bit?
ext.OS_NAME = System.getProperty("os.name").toLowerCase();
ext.OS_ARCH = System.getProperty("os.arch");
ext.IS_64 = OS_ARCH.toLowerCase().contains("64");
ext.IS_MAC = OS_NAME.contains("mac") || OS_NAME.contains("darwin");
ext.IS_WINDOWS = OS_NAME.contains("windows");
ext.IS_LINUX = OS_NAME.contains("linux");

// TODO I want to determine whether to build 64-bit or 32-bit not by the OS but by the version
// of Java being used, and potentially also based on some user specified flag. Specifically,
// on 64-bit windows or 64-bit linux I want to be able to compile 32-bit versions of everything.
// This implies that my various native intermediate directories need to be more than just
// linux- mac- or win-, but also need to include 32 or 64 bit markers.

// CompileTarget defines what we are trying to compile to. By default the CompileTarget
// will be the same as the platform running this build -- that is, Mac, Windows, or Linux.
// You may be performing a cross-compile (compiling for a platform other than the one
// you are using, such as iOS, ARM Hard Float (armhf) or ARM Soft Float (armvfp)
enum CompileTarget {
    MAC("mac", true),
    WIN("win", true),
    LINUX("linux", "gtk", true),
    IOS("ios", false),
    SWT("swt", true),
    ARM_HF("armhf", "lens", false),
    ARM_VFP("armvfp", "lens", false)

    final String name;
    final String glassName;
    final boolean isDesktop;

    CompileTarget(String name, boolean isDesktop) {
        this.name = name;
        this.glassName = name;
        this.isDesktop = isDesktop;
    }

    CompileTarget(String name, String glassName, boolean isDesktop) {
        this.name = name;
        this.glassName = glassName;
        this.isDesktop = isDesktop;
    }
}

// Check whether the COMPILE_TARGET property has been specified (if so, it was done by
// the user and not by this script). If it has been defined, then convert it from a
// String to a CompileTarget, and do some sanity checking.
if (hasProperty("COMPILE_TARGET")) {
    // Convert from whatever String was assigned to COMPILE_TARGET to an object
    for (CompileTarget target : CompileTarget.values()) {
        if (target.name.equals(COMPILE_TARGET.toLowerCase())) {
            COMPILE_TARGET = target;
            break;
        }
    }
} else {
    // Default to the right compile target for the platform
    ext.COMPILE_TARGET = IS_MAC ? CompileTarget.MAC : IS_WINDOWS ? CompileTarget.WIN : IS_LINUX ? CompileTarget.LINUX : null;
}

// TODO Need to add a "PIPELINE" property so that when compiling for ARM (for example) I can choose
// between building for the X11 and the EGLFB pipelines. Or, I need to be able to compile both and
// then just choose which to include in the final sdk based on a flag?

// The name of the glass platform to build, one of "gkt", "ios", "lens", "mac", "win", or "android"
// TODO Might also be different based on X11 or EGLFB?
ext.GLASS_PLATFORM = COMPILE_TARGET.glassName;

// Get the JDK_HOME automatically based on the version of Java used to execute gradle. Or, if specified,
// use a user supplied JDK_HOME, BINARY_STUB, JAVAC, and/or JAVAH, all of which may be specified
// independently (or we'll try to get the right one based on other supplied info). Sometimes the
// JRE might be the thing that is being used instead of the JRE embedded in the JDK, such as:
//    c:\Program Files (x86)\Java\jdk1.8.0\jre
//    c:\Program Files (x86)\Java\jre8\
// Because of this, you may sometimes get the jdk's JRE (in which case the logic we used to have here
// was correct and consistent with all other platforms), or it might be the standalone JRE (for the love!).
def envJavaHome = cygpath(System.getenv("JAVA_HOME"));
ext.JAVA_HOME = envJavaHome == null || envJavaHome.equals("") ? System.getProperty("java.home") : envJavaHome;
def javaHomeFile = file(JAVA_HOME);
defineProperty("JDK_HOME",
        javaHomeFile.name == "jre" ?
        javaHomeFile.getParent().toString() :
        javaHomeFile.name.startsWith("jre") ?
        new File(javaHomeFile.getParent(), "jdk1.${javaHomeFile.name.substring(3)}.0").toString() :
        JAVA_HOME); // we have to bail and set it to something and this is as good as any!
defineProperty("JAVA", cygpath("$JDK_HOME/bin/java${IS_WINDOWS ? '.exe' : ''}"));
defineProperty("JAVAC", cygpath("$JDK_HOME/bin/javac${IS_WINDOWS ? '.exe' : ''}"));
defineProperty("JAVAH", cygpath("$JDK_HOME/bin/javah${IS_WINDOWS ? '.exe' : ''}"));
defineProperty("JAVADOC", cygpath("$JDK_HOME/bin/javadoc${IS_WINDOWS ? '.exe' : ''}"));
defineProperty("JDK_DOCS", "http://download.oracle.com/javase/7/docs/api");
defineProperty("BINARY_STUB", cygpath("$JDK_HOME/jre/lib/ext/jfxrt.jar"));
ext.BINARY_STUB = "".equals(BINARY_STUB) ? null : files(BINARY_STUB);

// COMPILE_WEBKIT specifies whether to build all of webkit. COMPILE_GSTREAMER
// specifies whether to build GStreamer.
defineProperty("COMPILE_WEBKIT", "false")
defineProperty("COMPILE_GSTREAMER", "false")
ext.COMPILE_WEBKIT = Boolean.parseBoolean(COMPILE_WEBKIT)
ext.COMPILE_GSTREAMER = Boolean.parseBoolean(COMPILE_GSTREAMER)

// Define the SWT.jar that we are going to have to download during the build process based
// on what platform we are compiling from (not based on our target). SWT in particular is
// only used when we are compiling for desktop platforms.
ext.SWT_FILE_NAME = IS_MAC ? "org.eclipse.swt.cocoa.macosx.x86_64_3.7.2.v3740f" :
    IS_WINDOWS && IS_64 ? "org.eclipse.swt.win32.win32.x86_64_3.7.2.v3740f" :
    IS_WINDOWS && !IS_64 ? "org.eclipse.swt.win32.win32.x86_3.7.2.v3740f" :
    IS_LINUX && IS_64 ? "org.eclipse.swt.gtk.linux.x86_64_3.7.2.v3740f" :
    IS_LINUX && !IS_64 ? "org.eclipse.swt.gtk.linux.x86_3.7.2.v3740f" : "";

// Specify the build configuration (Release or Debug)
defineProperty("CONF", "Release");
ext.IS_DEBUG = CONF == "Debug";

// Defines the compiler warning levels to use. If empty, then no warnings are generated. If
// not empty, then the expected syntax is as a space or comma separated list of names, such
// as defined in the javac documentation.
defineProperty("LINT", "none");
ext.IS_LINT = LINT != "none";

defineProperty("DOC_LINT", "none");
ext.IS_DOC_LINT = DOC_LINT != "none";

// Specifies whether to use the "useDepend" option when compiling Java sources
defineProperty("USE_DEPEND", "false");
ext.USE_DEPEND = Boolean.parseBoolean(USE_DEPEND);

// Define the number of threads to use when compiling (specifically for native compilation)
defineProperty("NUM_COMPILE_THREADS", "${Runtime.runtime.availableProcessors()}");

// Now we need to define the native compilation tasks. The set of parameters to
// CC / LINK depends on the target platform (and also to some extent what platform
// you are compiling on). These settings are contained in various gradle files
// such as mac.gradle and linux.gradle and armhf.gradle. Additionally, the developer
// can specify COMPILE_FLAGS_FILE to be a URL or path to a different gradle file
// that will contain the appropriate flags.
defineProperty("COMPILE_FLAGS_FILE", "${COMPILE_TARGET.name}.gradle");
apply from: COMPILE_FLAGS_FILE;

// Define the programs to use for compiling and linking native code.
defineProperty("CC", "g++");
defineProperty("LINK", "g++");

// Define settings used when creating the VersionInfo. These settings are generally left alone
// by developers and set only from Hudson. We have to manually rev this version number from
// release to release.
defineProperty("HUDSON_JOB_NAME", "not_hudson");
defineProperty("HUDSON_BUILD_NUMBER","0000");
defineProperty("PROMOTED_BUILD_NUMBER", "00");
defineProperty("PRODUCT_NAME", "OpenJFX");
defineProperty("RAW_VERSION", "8.0.0");
defineProperty("RELEASE_NAME", "8.0");
defineProperty("RELEASE_MILESTONE", "ea");

/******************************************************************************
 *                                                                            *
 *                          Build Setup Sanity Checks                         *
 *                                                                            *
 *  Here we do a variety of checks so that if the version of Java you are     *
 *  building with is misconfigured, or you are using the wrong version of     *
 *  gradle, etc you will get some kind of helpful error / warning message     *
 *                                                                            *
 *****************************************************************************/

// Verify that the architecture & OS are supported configurations
if (!IS_MAC && !IS_WINDOWS && !IS_LINUX) logger.error("Unsupported build OS ${OS_NAME}")
if ((IS_WINDOWS && OS_ARCH != "i386" && OS_ARCH != "amd64" && OS_ARCH != "x86") || (IS_MAC && OS_ARCH != "x86_64")) {
    // TODO what are appropriate linux arch values?
    throw new Exception("Unknown and unsupported build architecture: $OS_ARCH")
}

// Sanity checking
if (COMPILE_TARGET == CompileTarget.MAC && !IS_MAC) throw new Exception("Must be on MacOSX to compile for MacOSX");
if (COMPILE_TARGET == CompileTarget.LINUX && !IS_LINUX) throw new Exception("Must be on Linux to compile for Linux");
if (COMPILE_TARGET == CompileTarget.WIN && !IS_WINDOWS) throw new Exception("Must be on Windows to compile for Windows");
if (COMPILE_TARGET == CompileTarget.IOS && !IS_MAC) throw new Exception("Must be on MacOSX to cross compile for iOS");
if (COMPILE_TARGET == CompileTarget.ARM_HF && !IS_LINUX) throw new Exception("Must be on Linux x86 to cross compile for ARM Hard Float");
if (COMPILE_TARGET == CompileTarget.ARM_VFP && !IS_LINUX) throw new Exception("Must be on Linux x86 to cross compile for ARM Soft Float");

// Sanity check that we're not building from a platform we didn't anticipate
if (COMPILE_TARGET == null) throw new Exception("Unable to determine compilation platform, or COMPILE_TARGET!");

// Make sure JAVA_HOME/bin/java exists
if (!file(JAVA).exists()) throw new Exception("Missing or incorrect path to 'java': '$JAVA'. Perhaps bad JDK_HOME? $JDK_HOME")
if (!file(JAVAC).exists()) throw new Exception("Missing or incorrect path to 'javac': '$JAVAC'. Perhaps bad JDK_HOME? $JDK_HOME")
if (!file(JAVAH).exists()) throw new Exception("Missing or incorrect path to 'javah': '$JAVAH'. Perhaps bad JDK_HOME? $JDK_HOME")
if (!file(JAVADOC).exists()) throw new Exception("Missing or incorrect path to 'javadoc': '$JAVADOC'. Perhaps bad JDK_HOME? $JDK_HOME")
if (BINARY_STUB != null && !BINARY_STUB.getSingleFile().exists()) logger.warn("Missing or incorrect path to 'jfxrt.jar': '${BINARY_STUB.asPath}'. Perhaps bad JDK_HOME? $JDK_HOME")

// Verify that CONF is something useful
if (CONF != "Release" && CONF != "Debug") logger.warn("Unknown configuration CONF='$CONF'. Treating as 'Release'");

// If the number of compile threads is less than 1 then we have a problem!
if (Integer.parseInt(NUM_COMPILE_THREADS.toString()) < 1) {
    logger.warn("NUM_COMPILE_THREADS was specified as '$NUM_COMPILE_THREADS' which is less than the minimum value of 1. " +
            "Building with a value of 1 instead.")
    NUM_COMPILE_THREADS = 1;
}

// Check that Gradle 1.4 is in use. We haven't tried any other versions.
if (gradle.gradleVersion != "1.4") {
    logger.warn("Unsupported gradle version $gradle.gradleVersion in use. Only 1.4 is supported")
}

/******************************************************************************
 *                                                                            *
 *                      Logging of Properties and Settings                    *
 *                                                                            *
 *  Log some of the settings we've determined. We could log more here, it     *
 *  doesn't really hurt.                                                      *
 *                                                                            *
 *****************************************************************************/

logger.info("OS_NAME: $OS_NAME");
logger.info("OS_ARCH: $OS_ARCH");
logger.info("JAVA_HOME: $JAVA_HOME");
logger.info("JDK_HOME: $JDK_HOME");
logger.info("BINARY_STUB: ${BINARY_STUB == null ? '' : BINARY_STUB.asPath}");
logger.info("HUDSON_JOB_NAME: $HUDSON_JOB_NAME");
logger.info("HUDSON_BUILD_NUMBER: $HUDSON_BUILD_NUMBER");
logger.info("PROMOTED_BUILD_NUMBER: $PROMOTED_BUILD_NUMBER");
logger.info("PRODUCT_NAME: $PRODUCT_NAME");
logger.info("RAW_VERSION: $RAW_VERSION");
logger.info("RELEASE_NAME: $RELEASE_NAME");
logger.info("RELEASE_MILESTONE: $RELEASE_MILESTONE");

/******************************************************************************
 *                                                                            *
 *                Definition of Native Code Compilation Tasks                 *
 *                                                                            *
 *    - JavaHeaderTask is used to run javah. The JAVAH property will point at *
 *      the version of javah to be used (i.e.: a path to javah)               *
 *    - CCTask compiles native code. Specifically it will compile .m, .c,     *
 *      .cpp, or .cc files. It uses the headers provided by the               *
 *      JavaHeaderTask plus additional platform specific headers. It will     *
 *      compile into .obj files. The CC property defines the compiler to use  *
 *      On Windows it will also process resource files.                       *
 *    - LinkTask will perform native linking and create the .dll / .so /      *
 *      .dylib as necessary. It uses the linker defined by the LINK property  *
 *                                                                            *
 *****************************************************************************/

// Save a reference to the buildSrc.jar file because we need it for actually
// compiling things, not just for the sake of this build script
// (such as generating the builders, JSL files, etc)
ext.BUILD_SRC = rootProject.files("buildSrc/build/libs/buildSrc.jar");

/**
* Convenience method for creating javah, cc, link, and "native" tasks in the given project. These
* tasks are parameterized by name, so that we can produce, for example, javahGlass, ccGlass, etc
* named tasks.
*/
void addNative(Project project, String name) {
    def javahTask = project.task("javah$name", type: JavaHeaderTask, dependsOn: project.classes, group: "Build") {
        description = "Generates JNI Headers for $name"
        source project.sourceSets.main.output.classesDir
        classpath = project.files(project.sourceSets.main.output.classesDir)
        if (rootProject.BINARY_STUB != null) classpath += rootProject.BINARY_STUB
        output = project.file("$project.buildDir/generated-src/headers/$name")
    }
    def ccTask = project.task("cc$name", type: CCTask, dependsOn: javahTask, group: "Build") {
        description = "Compiles native sources for $name"
        matches = ".*\\.c|.*\\.cpp|.*\\.m|.*\\.cc"
        headers = project.file("$project.buildDir/generated-src/headers/$name")
        output(file("$project.buildDir/native/$name"))
    }
    def linkTask = project.task("link$name", type: LinkTask, dependsOn: ccTask, group: "Build") {
        description = "Creates native dynamic library for $name"
        objectDir = file("$project.buildDir/native/$name")
    }
    if (IS_WINDOWS) {
        def rcTask = project.task("rc$name", type: CompileResourceTask, dependsOn: javahTask, group: "Build") {
            description = "Compiles native sources for $name"
            matches = ".*\\.rc|.*\\.cur"
            output(file("$project.buildDir/native/$name"))
        }
        linkTask.dependsOn rcTask;
    }
    project.task("native$name", dependsOn: linkTask, group: "Build") {
        description = "Generates JNI headers, compiles, and builds native dynamic library for $name"
    }
    project.assemble.dependsOn("native$name")
    project.task("cleanNative$name", group: "Build") << {
        project.delete("$project.buildDir/generated-src/headers")
        project.delete("$project.buildDir/native")
        project.delete("$project.buildDir/libs/${COMPILE_TARGET.name}")
    }
}

void addJSL(Project project, String name, Closure compile) {
    def lowerName = name.toLowerCase()

    def compileCompilers = project.task("compile${name}Compilers", type: JavaCompile, dependsOn: project.compileJava) {
        description = "Compile the $name JSL Compilers"
        classpath = project.files(project.sourceSets.main.output.classesDir) +
                rootProject.BUILD_SRC +
                project.configurations.antlr3
        source = [project.file("src/main/jsl-$lowerName")]
        destinationDir = project.file("$project.buildDir/classes/jsl-compilers/$lowerName")
    }

    def generateShaders = project.task("generate${name}Shaders", dependsOn: compileCompilers) {
        description = "Generate $name shaders from JSL"
        def sourceDir = project.file("src/main/jsl-$lowerName")
        def destinationDir = project.file("$project.buildDir/generated-src/jsl-$lowerName")
        inputs.dir sourceDir
        outputs.dir destinationDir
        doLast {
            compile(sourceDir, destinationDir)
        }
    }

    project.task("compile${name}JavaShaders", type: JavaCompile, dependsOn: generateShaders) {
        description = "Compile the Java $name JSL shaders"
        classpath = project.files(project.sourceSets.main.output.classesDir) + rootProject.BUILD_SRC
        source = [project.file("$project.buildDir/generated-src/jsl-$lowerName")]
        destinationDir = project.file("$project.buildDir/classes/jsl-$lowerName")
    }

    def compileHLSLShaders = project.task("compile${name}HLSLShaders", dependsOn: generateShaders, type: CompileHLSLTask) {
        enabled = IS_WINDOWS
        description = "Compile $name HLSL files into .obj files"
        matches = ".*\\.hlsl"
        output project.file("$project.buildDir/hlsl") // TODO!!
    }

    project.task("process${name}Shaders", dependsOn: [generateShaders, compileHLSLShaders], type: Copy, description: "Copy hlsl / frag shaders to build/resources/jsl-$lowerName") {
        from("$project.buildDir/hlsl") { // TODO!!
            include "**/*.obj"
        }
        from("$project.buildDir/generated-src/jsl-$lowerName") {
            include("**/*.frag")
        }
        into "$project.buildDir/resources/jsl-$lowerName"
    }
}

/*****************************************************************************
*        Project definitions (dependencies, etc)                             *
*****************************************************************************/

allprojects {
    // We want to configure all projects as java projects and use the same compile settings
    // etc, except for the root project which we just want to ignore
    if (project == rootProject || project.name == "media" || project.name == "web") return
    // All of our projects are java projects
    apply plugin: "java"
    sourceCompatibility = 1.7

    // Setup the repositories that we'll download libraries from. Maven Central is
    // just easy for most things. The custom "ivy" repo is for downloading SWT. The way it
    // works is to setup the download URL such that it will resolve to the actual jar file
    // to download. See SWT_FILE_NAME for the name of the jar that will be used as the
    // "artifact" in the pattern below. Note that the closed builds use different repositories
    // so if you are debugging a closed-build artifact related build issue, check out the
    // closed gradle file instead.
    repositories {
        mavenCentral()
        ivy {
            url "http://download.eclipse.org/eclipse/updates/3.7/R-3.7.2-201202080800/plugins/"
            layout "pattern", {
                artifact "[artifact].[ext]"
            }
        }
    }

    // By default all of our projects require junit for testing so we can just
    // setup this dependency here.
    dependencies {
        testCompile(group: "junit", name: "junit", version: "4.8.2");
    }

    // At the moment the ASM library shipped with Gradle that is used to
    // discover the different test classes fails on Java 8, so in order
    // to have sourceCompatibility set to 1.8 I have to also turn scanForClasses off
    // and manually specify the includes / excludes. At the moment we use
    // Java 7 but when we switch to 8 this will be needed, and probably again when
    // we start building with Java 9.
    test {
        jvmArgs("-Djava.ext.dirs=");
        if (rootProject.BINARY_STUB != null) classpath += rootProject.BINARY_STUB;
        executable = JAVA;
        enableAssertions = true;
        testLogging.exceptionFormat = "full";
        scanForTestClasses = false;
        include("**/*Test.*");
        exclude("**/DepthTest.*");
        exclude("**/*Abstract*.*");
    }

    // Exclude any non-public-API classes from having javadoc generated. This block is used
    // when generating JavaDocs for a specific project. When generating the JavaDocs for the
    // entire SDK, a different javadoc command is used (see the javadoc task on the top level)
    javadoc {
        exclude("com/**/*", "javafx/scene/ParentDesignInfo*", "Compile*", "javafx/builder/**/*");
        executable = JAVADOC;
        options.windowTitle("JavaFX Project ${project.name} ${RELEASE_NAME}")
        options.links(JDK_DOCS);
        options.addBooleanOption("XDignore.symbol.file").setValue(true);
        options.addBooleanOption("Xdoclint:none").setValue(!IS_DOC_LINT);
        options.addBooleanOption("javafx").setValue(true);
        // All doc-files are located in src/main/docs because Gradle's javadoc doesn't copy
        // over the doc-files if they are embedded with the sources. I find this arrangement
        // somewhat cleaner anyway (never was a fan of mixing javadoc files with the sources)
        doLast {
            copy {
                from "src/main/docs"
                into "$buildDir/docs/javadoc"
            }
        }
    }
}

// The "base" project is our first module and the most basic one required for
// all other modules. It is useful even for non-GUI applications.
project(":base") {
    dependencies {
        compile BUILD_SRC
    }

    // We need to take the VersionInfo.java file and replace the various
    // properties within it
    def replacements = [
        "BUILD_TIMESTAMP": new java.util.Date(),
        "HUDSON_JOB_NAME": HUDSON_JOB_NAME,
        "HUDSON_BUILD_NUMBER": HUDSON_BUILD_NUMBER,
        "PROMOTED_BUILD_NUMBER": PROMOTED_BUILD_NUMBER,
        "PRODUCT_NAME": PRODUCT_NAME,
        "RAW_VERSION": RAW_VERSION,
        "RELEASE_NAME": RELEASE_NAME,
        "RELEASE_MILESTONE": RELEASE_MILESTONE];
    task processVersionInfo(type: Copy, description: "Replace params in VersionInfo and copy file to destination") {
        doFirst { mkdir "$buildDir/generated-src/version-info" }
        from "src/main/version-info"
        into "$buildDir/generated-src/version-info/com/sun/javafx/runtime"
        filter {line->
            replacements.each() {k, v ->
                line = line.replace("@$k@", v.toString());
            }
            line
        }
    }

    // Make sure to include $buildDir/generated-src/version-info that we previously created.
    // We DO NOT want to include src/main/version-info
    sourceSets.main.java.srcDirs = ["src/main/java", "$buildDir/generated-src/version-info"]
    compileJava.dependsOn processVersionInfo
}

// The graphics module is needed for any graphical JavaFX application. It requires
// the base module and includes the scene graph, layout, css, prism, windowing, etc.
// This is a fairly complicated module. There are many different types of native components
// that all need to be compiled.
project(":graphics") {
    // Workaround for lack of Antlr 3 support in Gradle. By defining a configuration,
    // we can then give it a class path and use that classpath to execute a java command
    getConfigurations().add("antlr3");

    sourceSets {
        main
        test
        stub
    }

    dependencies {
        compile project(":base"), BUILD_SRC, files("$JDK_HOME/jre/lib/plugin.jar")
        compile name: SWT_FILE_NAME
        stubCompile group: "junit", name: "junit", version: "4.8.2",
            project(":base").sourceSets.test.output, sourceSets.main.output
        antlr3 group: "org.antlr", name: "antlr", version: "3.1.3"
    }

    // Add the tasks for native compilation of Glass
    addNative(project, "Glass");
    javahGlass.include("com/sun/glass/events/**",
                "com/sun/glass/ui/*",
                "com/sun/glass/ui/$GLASS_PLATFORM/*",
                "com/sun/glass/ui/accessible/$GLASS_PLATFORM/*");
    ccGlass.params.addAll(GLASS_CC_FLAGS);
    ccGlass.source(file("src/main/native-glass/$GLASS_PLATFORM"));
    linkGlass.linkParams.addAll(GLASS_LINK_FLAGS);
    linkGlass.lib = file("$project.buildDir/libs/${COMPILE_TARGET.name}/${library('glass')}");

    // Add the tasks for native compilation of Prism
    addNative(project, "Prism")
    javahPrism.include("com/sun/prism/impl/**/*", "com/sun/prism/PresentableState*");
    ccPrism.compiler = PRISM_CC;
    ccPrism.params.addAll(CC_FLAGS);
    ccPrism.source(file("src/main/native-prism"));
    linkPrism.linkParams.addAll(PRISM_LINK_FLAGS);
    linkPrism.lib = file("$project.buildDir/libs/${COMPILE_TARGET.name}/${library('prism-common')}");

    // Add the tasks for native compilation of Prism Software Pipeline
    addNative(project, "PrismSW")
    javahPrismSW.include "com/sun/pisces/**/*"
    ccPrismSW.compiler = PRISM_SW_CC;
    ccPrismSW.params.addAll(PRISM_SW_CC_FLAGS);
    ccPrismSW.source(file("src/main/native-prism-sw"));
    linkPrismSW.linkParams.addAll(PRISM_SW_LINK_FLAGS);
    linkPrismSW.lib = file("$project.buildDir/libs/${COMPILE_TARGET.name}/${library('prism-sw')}");

    // The Decora and Prism JSL files have to be generated in a very specific set of steps.
    //      1) Compile the *Compile.java classes. These live in src/main/jsl-* and will be
    //         output to $buildDir/classes/jsl-compilers/* (where * == decora or prism).
    //      2) Generate source files from the JSL files contained in src/main/jsl-*. These
    //         will be output to $buildDir/generated-src/jsl-*
    //      3) Compile the JSL Java sources in $buildDir/generated-src/jsl-* and put the output
    //         into classes/jsl-*
    //      4) Compile the native JSL sources in $buildDir/generated-src/jsl-* and put the obj
    //         files into native/jsl-* and the resulting library into libs/jsl-*.dll|so|dylib
    //      5) Modify the jar step to include classes/jsl-*
    // The native library must be copied over during SDK creation time in the "sdk" task. In
    // addition to these steps, the clean task is created. Note that I didn't bother to create
    // a new task for each of the decora files, preferring instead just to create a rule?? Also
    // need "clean" tasks for each compile task.

    addJSL(project, "Decora") { sourceDir, destinationDir ->
        [[fileName: "ColorAdjust", generator: "CompileJSL", outputs: "-all"],
         [fileName: "Brightpass", generator: "CompileJSL", outputs: "-all"],
         [fileName: "SepiaTone", generator: "CompileJSL", outputs: "-all"],
         [fileName: "PerspectiveTransform", generator: "CompileJSL", outputs: "-all"],
         [fileName: "DisplacementMap", generator: "CompileJSL", outputs: "-all"],
         [fileName: "InvertMask", generator: "CompileJSL", outputs: "-all"],
         [fileName: "Blend", generator: "CompileBlend", outputs: "-all"],
         [fileName: "PhongLighting", generator: "CompilePhong", outputs: "-all"],
         [fileName: "LinearConvolve", generator: "CompileLinearConvolve", outputs: "-hw"],
         [fileName: "LinearConvolveShadow", generator: "CompileLinearConvolve", outputs: "-hw"]].each { settings ->
            javaexec {
                executable = JAVA
                workingDir = "modules/graphics"
                main = settings.generator
                classpath = configurations.compile + configurations.antlr3
                classpath += files("$buildDir/classes/main")
                classpath += files("$buildDir/classes/jsl-compilers/decora")
                args = ["-i", sourceDir, "-o", destinationDir, "-t", "-pkg", "com/sun/scenario/effect", "$settings.outputs", "$settings.fileName"]
                jvmArgs "-Djava.ext.dirs="
            }
        }
    }

    task generateDecoraNativeHeaders(type: JavaHeaderTask, dependsOn: compileDecoraJavaShaders) {
        description = "Generates JNI Headers for Decora SSE Natives"
        source file("$buildDir/classes/jsl-decora")
        source file("$buildDir/classes/main")
        include("com/sun/scenario/effect/impl/sw/sse/*");
        classpath = files("$buildDir/classes/main", "$buildDir/classes/jsl-decora")
        output = file("$buildDir/generated-src/headers/jsl-decora")
    }

    task compileDecoraNativeShaders(type: CCTask, dependsOn: generateDecoraNativeHeaders) {
        description = "Compiles Decora SSE natives"
        matches = ".*\\.cc"
        source file("$buildDir/generated-src/jsl-decora")
        source file("src/main/native-decora")
        headers = file("$buildDir/generated-src/headers/jsl-decora")
        params.addAll(DECORA_CC_FLAGS);
        output(file("$buildDir/native/jsl-decora"))
    }

    task linkDecoraNativeShaders(type: LinkTask, dependsOn: compileDecoraNativeShaders) {
        description = "Creates native dynamic library for Decora SSE"
        objectDir = file("$buildDir/native/jsl-decora")
        linkParams.addAll(DECORA_LINK_FLAGS);
        lib = file("$buildDir/libs/${COMPILE_TARGET.name}/${library('decora-sse')}");
    }

    compileDecoraHLSLShaders.source "$buildDir/generated-src/jsl-decora/com/sun/scenario/effect/impl/hw/d3d/hlsl/"

    task nativeDecora(dependsOn: [linkDecoraNativeShaders, compileDecoraHLSLShaders]);

    // Prism JSL
    addJSL(project, "Prism") { sourceDir, destinationDir ->
        def inputFiles = fileTree(dir: sourceDir)
        inputFiles.include "**/*.jsl"
        inputFiles.each { file ->
            javaexec {
                executable = JAVA
                workingDir = "modules/graphics"
                main = "CompileJSL"
                classpath = configurations.compile + configurations.antlr3
                classpath += files("$buildDir/classes/jsl-compilers/prism", "modules/graphics/src/main/jsl-prism") // for the .stg
                args = ["-i", sourceDir, "-o", destinationDir, "-t", "-pkg", "com/sun/prism", "-d3d", "-es2", "-name", "$file"]
                jvmArgs "-Djava.ext.dirs="
            }
        }
    }

    compilePrismHLSLShaders.source "$buildDir/generated-src/jsl-prism/com/sun/prism/d3d/hlsl/"
    classes.dependsOn compilePrismJavaShaders;
    nativePrism.dependsOn compilePrismHLSLShaders;

    // Create a single "native" task which will depend on all the individual native tasks for graphics
    task("native", dependsOn: [nativeGlass, nativePrism, nativePrismSW, nativeDecora]) {
        group = "Build"
        description = "Compiles and Builds all native libraries for Graphics"
    }
    assemble.dependsOn nativeDecora
    processResources.dependsOn processDecoraShaders, processPrismShaders

    // The graphics project needs to completely replace the "test" task because the
    // tests have been split among the normal tests and the stub tests. I want to make sure
    // that invoking "graphics:test" runs both of these tasks, rather than only one of them.
    tasks.replace("test")
    test {
        group = "Verification"
        description = "Runs all the unit tests for Graphics"
    }
    task testWithoutStub(type: Test, dependsOn: ":graphics:compileJava", group: "Verification") {
        jvmArgs "-Djava.ext.dirs="
        classpath = sourceSets.test.runtimeClasspath
        if (rootProject.BINARY_STUB != null) classpath += rootProject.BINARY_STUB
    }
    task testWithStub(type: Test, dependsOn: [":graphics:compileJava"], group: "Verification") {
        jvmArgs "-Djava.ext.dirs=", "-Djavafx.toolkit=com.sun.javafx.pgstub.StubToolkit", "-DCSS_META_DATA_TEST_DIR=${file('$buildDir/classes/main/javafx')}"
        classpath = sourceSets.stub.runtimeClasspath + sourceSets.main.runtimeClasspath
        if (rootProject.BINARY_STUB != null) classpath += rootProject.BINARY_STUB
        testClassesDir = file("$buildDir/classes/stub")
        testResultsDir = file("$buildDir/stub-results")
        testReportDir = file("$buildDir/reports/stub")
    }
    [testWithoutStub, testWithStub].each { test ->
        test.enableAssertions = true
        test.testLogging.exceptionFormat = "full"
        test.scanForTestClasses = false
        test.include "**/*Test.*"
        test.exclude "**/*Abstract*.*"
    }
    test.dependsOn testWithoutStub, testWithStub

}

project(":controls") {
    dependencies {
        compile BUILD_SRC, project(":base"), project(":graphics"), project(":designTime")
        // TODO not sure how to specify this? processResources project(":base"), project(":graphics")
        testCompile project(":graphics").sourceSets.stub.output
    }

    test {
        jvmArgs "-Djavafx.toolkit=com.sun.javafx.pgstub.StubToolkit"
        // TODO fix the Controls tests so that we can run them all in one VM
        // This is highly unfortunate, test execution time goes from 7 sec to 2 min 8 sec
        // however there are 8 failing tests when we don't fork. Need to fix those tests.
        forkEvery = 1
    }

    // TODO Css2Bin really should be moved out and put into buildSrc if it can be
    // TODO could change script to dynamically locate all .css files and create bss for them, probably better
    // TODO also not sure there is any benefit to having css files in the jfxrt.jar at all
    processResources << {
        ["$buildDir/resources/main/com/sun/javafx/scene/control/skin/caspian/caspian.css",
        "$buildDir/resources/main/com/sun/javafx/scene/control/skin/caspian/embedded-qvga.css",
        "$buildDir/resources/main/com/sun/javafx/scene/control/skin/caspian/embedded.css",
        "$buildDir/resources/main/com/sun/javafx/scene/control/skin/caspian/fxvk.css",
        "$buildDir/resources/main/com/sun/javafx/scene/control/skin/caspian/highcontrast.css",
        "$buildDir/resources/main/com/sun/javafx/scene/control/skin/modena/modena.css",
        "$buildDir/resources/main/com/sun/javafx/scene/control/skin/modena/touch.css"].each { css ->
            javaexec {
                executable = JAVA
                workingDir = "modules/controls"
                classpath files("$buildDir/classes/main",
                        project(":graphics").sourceSets.main.output,
                        project(":base").sourceSets.main.output)
                main = "com.sun.javafx.css.parser.Css2Bin"
                args css
                jvmArgs "-Djava.ext.dirs="
            }
        }
    }
}

project(":swing") {
    // Skip Swing compilation when not on a compile target for MAC, WIN, LINUX
    if(COMPILE_TARGET != CompileTarget.WIN && COMPILE_TARGET != CompileTarget.MAC && COMPILE_TARGET != CompileTarget.LINUX) {
        tasks { enabled = false; }
    }

    dependencies {
        compile BUILD_SRC, project(":base"), project(":graphics")
    }
}

project(":swt") {
    // Skip SWT compilation when not on a compile target for MAC, WIN, LINUX
    if(COMPILE_TARGET != CompileTarget.WIN && COMPILE_TARGET != CompileTarget.MAC && COMPILE_TARGET != CompileTarget.LINUX) {
        tasks { enabled = false; }
    }

    dependencies {
        compile BUILD_SRC, project(":base"), project(":graphics")
        compile name: SWT_FILE_NAME
    }
}

project(":fxml") {
    dependencies {
        compile BUILD_SRC, project(":base"), project(":graphics"),
                project(":controls"), project(":swt"), project(":swing")
        testCompile project(":graphics").sourceSets.stub.output
    }
    test {
        // StubToolkit is not *really* needed here, but because some code inadvertently invokes performance
        // tracker and this attempts to fire up the toolkit and this looks for native libraries and fails,
        // we have to use the stub toolkit for now.
        jvmArgs "-Djavafx.toolkit=com.sun.javafx.pgstub.StubToolkit"
    }
}

project(":designTime") {
    dependencies {
        compile project(":graphics")
    }
}

project(":fxpackager") {
    // fxpackager has a dependency on ant in order to build the ant jar,
    // and as such needs to point to the apache binary repository
    repositories {
        maven {
            url "https://repository.apache.org"
        }
    }

    dependencies {
        compile group: "org.apache.ant", name: "ant", version: "1.8.2"
    }

    // When producing the jar, we need to relocate a few class files
    // from their normal location to a resources/classes or resources/web-files
    // location
    jar {
        includeEmptyDirs = false
        archiveName = "ant-javafx.jar"
        eachFile { FileCopyDetails details ->
            if (details.path.startsWith("com/javafx/main")) {
                details.path = "resources/classes/$details.path"
            } else if (details.path.startsWith("web-files")) {
                details.path = "resources/$details.path"
            }
        }
    }

    // The "man" task will create a $buildDir/man containing the man
    // files for the system being built
    task man(type: Copy) {
        includeEmptyDirs = false
        enabled = IS_LINUX || IS_MAC
        from "src/main/man"
        into "$buildDir/man"
        exclude "**/*.html"
        if (IS_MAC) exclude "**/ja_JP.UTF-8/**"
    }
    processResources.dependsOn man

    // Compile the native launchers. These are included in ant-javafx.jar
    if (IS_WINDOWS) {
        task compileWinLauncher(type: CCTask, group: "Build") {
            description = "Compiles native sources for the application co-bundle launcher";
            matches = "WinLauncher\\.cpp";
            params.addAll(LAUNCHER_CC_FLAGS);
            output(file("$buildDir/native/WinLauncher"));
            source(file("src/main/native/launcher/win"));
            exe = true;
            linkerOptions.addAll(LAUNCHER_LINK_FLAGS);
            doLast {
                copy {
                    from "$buildDir/native/WinLauncher/WinLauncher.exe"
                    into "$buildDir/classes/main/com/sun/javafx/tools/resource/windows"
                }
            }
        }
        task compileIconSwap(type: CCTask, group: "Build") {
            description = "Compiles native sources for the application co-bundle launcher"
            matches = "IconSwap\\.cpp"
            params.addAll(ICON_LAUNCHER_CC_FLAGS)
            output(file("$buildDir/native/IconSwap"))
            source file("src/main/native/launcher/win")
            exe = true
            linkerOptions.addAll(ICON_LAUNCHER_LINK_FLAGS)
            doLast {
                copy {
                    from "$buildDir/native/IconSwap/IconSwap.exe"
                    into "$buildDir/classes/main/com/sun/javafx/tools/resource/windows"
                }
            }
        }
        task compileLauncher(dependsOn: [compileWinLauncher, compileIconSwap])
    } else {
        task compileLauncher(type: CCTask, group: "Build") {
            description = "Compiles native sources for the application co-bundle launcher"
            if (IS_MAC) {
                matches = ".*\\.m"
                output(file("$buildDir/classes/main/com/sun/javafx/tools/resource/mac"))
                params.addAll(LAUNCHER_CC_FLAGS);
                source file("src/main/native/launcher/mac")
                eachOutputFile = { f ->
                    return new File(f.getParent(), "JavaAppLauncher")
                }
            } else {
                matches = ".*\\.c"
                output(file("$buildDir/classes/main/com/sun/javafx/tools/resource/linux"))
                params.addAll(LAUNCHER_CC_FLAGS)
                linkerOptions.addAll(LAUNCHER_LINK_FLAGS)
                source file("src/main/native/launcher/linux")
                eachOutputFile = { f ->
                    return new File(f.getParent(), "JavaAppLauncher")
                }
            }
        }
    }
    jar.dependsOn compileLauncher;

    // Builds the javafxpackager executable. For everything other than windows,
    // this is simply moving the existing shell script and ensuring it has proper
    // permissions. For Windows, this includes compiling the native executable
    if (IS_WINDOWS){
        task buildJavaFXPackager(type: CCTask, group: "Build") {
            description = "Compiles native sources for javafxpackager.exe"
            matches = "javafxpackager\\.cpp"
            params.addAll(["/nologo", "/W3", "/EHsc", "/MT", "/GS",
                    "/DWIN32", "/D_LITTLE_ENDIAN", "/DWIN32_LEAN_AND_MEAN",
                    "/D_WIN32_WINDOWS=0X0500", "/D_WIN32_WINNT=0X0500",
                    "/I$JDK_HOME/include", "/I$JDK_HOME/include/win32", "/arch:SSE", "/fp:fast",
                    "/O2", "-c"])
            output(file("$buildDir/native/javafxpackager"))
            source file("src/main/native/javafxpackager/win")
            doLast {
                mkdir "$buildDir/native"
                exec({
                    commandLine("$RC", "/nologo", "/l", "0x409", "/r", "/dJFX_DVERSION=8", "/dJFX_VERSION=8",
                            "/fo$buildDir/native/javafxpackager/javafxpackager.res",
                            "src/main/native/javafxpackager/win/javafxpackager.rc");
                    environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT);
                });
            }
            doLast {
                mkdir "$buildDir/javafxpackager"
                exec({
                    commandLine("$LINK", "/nologo", "/opt:REF", "/incremental:no", "/manifest", "kernel32.lib", "advapi32.lib",
                            "/out:$buildDir/native/javafxpackager/javafxpackager.exe",
                            "$buildDir/native/javafxpackager/javafxpackager.obj",
                            "$buildDir/native/javafxpackager/javafxpackager.res")
                    environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
                })
            }
            doLast {
                copy {
                    from file("src/main/native/javafxpackager/win/javafxpackager.manifest")
                    into file("$buildDir/native/javafxpackager")
                }
                // TODO, not sure MT.exe is actually being used currently, so for now skipping.
//                exec({
//                    commandLine("$MT -nologo -manifest $buildDir/native/javafxpackager/javafxpackager.manifest")
//                    environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
//                })
                copy {
                    from file("$buildDir/native/javafxpackager/javafxpackager.exe")
                    into file("$buildDir/javafxpackager")
                }
            }
        }
    } else {
        task buildJavaFXPackager(group: "Build") << {
            copy {
                from "src/main/native/javafxpackager/shell"
                into "$buildDir/javafxpackager"
                fileMode = 0755
            }
        }
    }

    jar.dependsOn buildJavaFXPackager
}

allprojects {
    // The following block is a workaround for the fact that presently Gradle
    // can't set the -XDignore.symbol.file flag, because it appears that the
    // javac API is lacking support for it. So what we'll do is find any Compile
    // task and manually provide the options necessary to fire up the
    // compiler with the right settings.
    //
    // Also, we need to remove jfxrt.jar from the ext classpath (if it is there)
    // and instead each module that depends on closed bits is going to need to
    // add BINARY_STUB to its list of dependencies.
    tasks.withType(Compile) { compile ->
        // Defer actually creating generated-src/builders until task execution
        doFirst {
            mkdir("$buildDir/generated-src/builders");
        }
        // It looks like we have to use ant to compile instead of the built-in gradle
        // compiler stuff because otherwise it won't compile on CYGWIN
        // TODO need to file issue with Gradle
        compile.options.useAnt = true
        compile.options.debug = true // we always generate debugging info in the class files
        compile.options.debugOptions.debugLevel = IS_DEBUG ? "source,lines,vars" : "source,lines"
        compile.options.fork = true
        compile.options.forkOptions.executable = JAVAC
        compile.options.warnings = IS_LINT
        compile.options.useDepend = USE_DEPEND
        compile.options.compilerArgs = ["-Djava.ext.dirs=", "-XDignore.symbol.file", "-encoding", "UTF-8"]

        // Add in the -Xlint options
        if (IS_LINT) {
            LINT.split("[, ]").each { s ->
                compile.options.compilerArgs += "-Xlint:$s"
            }
        }

        // Somewhat dangerous in case there is a java source set other than "test" or "stub" or "main"!
        // Note that the compileFooJava task is automatically created whenever a source set is
        // defined. So the "test" source set automatically creates a "compileTestJava" task (among others).
        if (name == "compileTestJava") {
            classpath = sourceSets.test.compileClasspath
            if (rootProject.BINARY_STUB != null) classpath += rootProject.BINARY_STUB
        } else if (name == "compileStubJava") {
            classpath = sourceSets.stub.compileClasspath
            if (rootProject.BINARY_STUB != null) classpath += rootProject.BINARY_STUB
        } else if (name == "compileJava") {
            // Not everything needs the builder processor
            if (["graphics", "controls", "swing", "swt", "base", "fxml"].contains(project.name)){
                compile.options.compilerArgs += ["-s", "$buildDir/generated-src/builders"]
                compile.options.compilerArgs += ["-processor", "javafx.builder.processor.BuilderProcessor"]
            }
            classpath = sourceSets.main.compileClasspath
            if (rootProject.BINARY_STUB != null) classpath += rootProject.BINARY_STUB
        } else {
            logger.info("Not using BINARY_STUB in compilation: $name")
        }
    }
}

/******************************************************************************
 *                                                                            *
 *                             Top Level Tasks                                *
 *                                                                            *
 *  These are the tasks which are defined only for the top level project and  *
 *  not for any sub projects. These are generally the entry point that is     *
 *  used by Hudson and by the continuous build system.                        *
 *                                                                            *
 *****************************************************************************/

task clean() {
    group = "Basic"
    description = "Deletes the build directory and the build directory of all sub projects"
    getSubprojects().each { subProject ->
        dependsOn(subProject.getTasksByName("clean", true));
    }
    doLast {
        delete(buildDir);
    }
}

// The jfxrt task is responsible for creating the jfxrt.jar. A developer may
// have multiple SDK's on their system at any one time, depending on which
// cross compiles they have done. For example, I might have:
//      build/mac-sdk/rt/lib/ext/jfxrt.jar
//      build/ios-sdk/rt/lib/ext/jfxrt.jar
//      build/win-sdk/rt/lib/ext/jfxrt.jar
//      build/armhf-sdk/rt/lib/ext/jfxrt.jar
//
// and so forth. This arrangement allows for multiple independent SDKs to
// exist on a developer's system.
task jfxrt(type: Jar) {
    group = "Basic"
    description = "Creates the jfxrt.jar"
    archiveName = "build/${COMPILE_TARGET.name}-sdk/rt/lib/ext/jfxrt.jar";
    includeEmptyDirs = false
    from("modules/base/build/classes/main",
         "modules/base/build/resources/main",
         "modules/graphics/build/classes/main",
         "modules/graphics/build/resources/main",
         "modules/controls/build/classes/main",
         "modules/controls/build/resources/main",
         "modules/fxml/build/classes/main",
         "modules/fxml/build/resources/main",
         "modules/graphics/build/classes/jsl-decora",
         "modules/graphics/build/resources/jsl-decora",
         "modules/graphics/build/classes/jsl-prism",
         "modules/graphics/build/resources/jsl-prism");
    exclude("js/**/*", // er...
            "PrismLoaderBackend*", // More decora stuff
            "**/*.stg",    // any glue files for decora must be excluded
            "**/*.java");  // Builder java files are in build/classes and should be excluded

    // We only need to include Swing & SWT when we're building for one of the desktop
    // compile targets (mac, win, linux, swt), not when we're building for iOS etc.
    if (COMPILE_TARGET.isDesktop) {
        from("modules/swing/build/classes/main",
             "modules/swing/build/resources/main",
             "modules/swt/build/classes/main",
             "modules/swt/build/resources/main");
    }

    // Filter out platform specific Java sources (glass) when compiling for other targets
    if (COMPILE_TARGET != CompileTarget.WIN) exclude("**/*.hlsl", "com/sun/glass/ui/win",
            "com/sun/glass/ui/accessible/win", "com/sun/prism/d3d",
            "com/sun/prism/es2/gl/win", "com/sun/prism/null3d", "com/sun/scenario/effect/impl/hw/d3d");
    if (COMPILE_TARGET != CompileTarget.IOS) exclude("com/sun/glass/ui/ios");
    if (COMPILE_TARGET != CompileTarget.MAC) exclude("com/sun/glass/events/mac",
            "com/sun/glass/ui/mac", "com/sun/glass/ui/accessible/mac");
    if (COMPILE_TARGET != CompileTarget.LINUX) exclude("com/sun/glass/ui/gtk");
    if (COMPILE_TARGET != CompileTarget.LINUX &&
            COMPILE_TARGET != CompileTarget.ARM_HF &&
            COMPILE_TARGET != CompileTarget.ARM_VFP) exclude("com/sun/glass/ui/lens",
                "com/sun/prism/es2/gl/eglfb", "com/sun/prism/es2/gl/eglx11",
                "com/sun/prism/es2/gl/x11");
    if (COMPILE_TARGET != CompileTarget.ARM_HF && COMPILE_TARGET != CompileTarget.ARM_VFP)
        exclude("com/sun/prism/es2/gl/eglfb", "com/sun/prism/es2/gl/eglx11");
    if (COMPILE_TARGET != CompileTarget.SWT) exclude("com/sun/glass/ui/swt");

    dependsOn(subprojects.collect { project -> project.getTasksByName("assemble", true)});
}

task javadoc(type: Javadoc) {
    group = "Basic"
    description = "Generates the JavaDoc for all the public API"
    executable = JAVADOC
    def projectsToDocument = [
            project(":base"), project(":graphics"), project(":controls"),
            project(":swing"), project(":swt"), project(":fxml")]
    source(projectsToDocument.collect({
        [it.sourceSets.main.java, "$it.buildDir/generated-src/builders"]
    }));
    setDestinationDir(new File(buildDir, 'javadoc'));
    // Might need a classpath
    classpath = files(projectsToDocument.collect { project ->
        project.sourceSets.main.compileClasspath
    });
    classpath += files(projectsToDocument.collect { project ->
        project.sourceSets.main.output
    });
    exclude("com/**/*", "javafx/scene/ParentDesignInfo*", "Compile*", "javafx/builder/**/*");
    options.windowTitle("JavaFX ${RELEASE_NAME}")
    options.links(JDK_DOCS);
    options.addBooleanOption("XDignore.symbol.file").setValue(true);
    options.addBooleanOption("Xdoclint:none").setValue(!IS_DOC_LINT);
    options.addBooleanOption("javafx").setValue(true);
    doLast {
        projectsToDocument.each { p ->
            copy {
                from "$p.projectDir/src/main/docs"
                into "$buildDir/javadoc"
            }
        }
    }

    dependsOn(projectsToDocument.collect { project -> project.getTasksByName("classes", true)});
}

// The 'sdk' task will build the rest of the SDK, and depends on the 'jfxrt' task. After
// executing this task the sdk bundle for the current COMPILE_TARGET will be fully created.
task sdk {
    group = "Basic"
    description = "Creates an SDK"
    doLast {
        // TODO instead of using copy everywhere, I probably want to use "sync" instead?
        // Copy all of the .dll / .so / .dylib native libraries into build/sdk/rt/lib/
        copy {
            from("modules/graphics/build/libs/${COMPILE_TARGET.name}/${library('decora-sse')}",
                 "modules/graphics/build/libs/${COMPILE_TARGET.name}/${library('prism-common')}",
                 "modules/graphics/build/libs/${COMPILE_TARGET.name}/${library('prism-sw')}",
                 "modules/graphics/build/libs/${COMPILE_TARGET.name}/${library('glass')}");
            if (IS_WINDOWS) {
                rename("lib(.*).dll", "\$1.dll");
            }
            if (COMPILE_TARGET == CompileTarget.MAC || COMPILE_TARGET == CompileTarget.IOS) {
                into("build/${COMPILE_TARGET.name}-sdk/rt/lib");
            } else if (COMPILE_TARGET == CompileTarget.WIN) {
                into("build/${COMPILE_TARGET.name}-sdk/rt/bin");
            } else {
                into("build/${COMPILE_TARGET.name}-sdk/rt/lib/$OS_ARCH");
            }
        }

        // Create the javafx.properties file
        final File javafxProperties = file("build/${COMPILE_TARGET.name}-sdk/rt/lib/javafx.properties");
        javafxProperties << "javafx.runtime.version=$RAW_VERSION";

        // Copy over the javadocs that were generated. This is done rather than just generating
        // the docs into the "right place" because for a cross-compile you only need one set of
        // docs but need to have a copy in each created sdk
        copy {
            from("build/javadoc");
            into("build/${COMPILE_TARGET.name}-sdk/docs/api");
        }

        // Copy over the fxpackager and rename as ant-javafx.jar
        copy {
            from "modules/fxpackager/build/libs"
            into "build/${COMPILE_TARGET.name}-sdk/lib"
        }

        // Copy over the FXPackager man files
        copy {
            from "modules/fxpackager/build/man"
            into "build/${COMPILE_TARGET.name}-sdk/man"
        }

        // Copy over the javafxpackager executable
        copy {
            from "modules/fxpackager/build/javafxpackager"
            into "build/${COMPILE_TARGET.name}-sdk/bin"
        }
    }
    dependsOn(jfxrt);
    dependsOn(javadoc);
}

task integrationCheck {
    group = "Basic"
    description = "Performs all the tasks necessary to ensure that the current build is ready for integration."
    dependsOn sdk
    dependsOn subprojects.collect { project -> project.getTasksByName("check", true)}
}

/******************************************************************************
 *                                                                            *
 *                 Generation of NetBeans Project Files                       *
 *                                                                            *
 *  This next section is responsible for setting up the work for generation   *
 *  of NetBeans project files. The developer needs to invoke                  *
 *                                                                            *
 *      gradle netbeans                                                       *
 *                                                                            *
 *  and all necessary project files will be generated. Note that unlike       *
 *  Eclipse and IDEA, NetBeans natively understands Gradle build files so     *
 *  the project files generated for NetBeans is limited to just shared        *
 *  configuration files. Make sure you have the latest stable release of      *
 *                                                                            *
 *  http://plugins.netbeans.org/plugin/44510/gradle-support                   *
 *                                                                            *
 *  for your version of the IDE.                                              *
 *                                                                            *
 *****************************************************************************/

/*
  <built-in-tasks>
    <task>
      <display-name>build</display-name>
      <non-blocking>yes</non-blocking>
      <task-names>
        <name must-exist="no">build</name>
      </task-names>
      <task-args>
        <arg>-PSUPPLEMENTAL_BUILD_FILE=../rt-closed/closed-build.gradle</arg>
      </task-args>
      <task-jvm-args/>
    </task>
  </built-in-tasks>
  <common-tasks>
    <task>
      <display-name>sdk</display-name>
      <non-blocking>no</non-blocking>
      <task-names>
        <name must-exist="yes">tasks</name>
      </task-names>
      <task-args>
        <arg>-PSUPPLEMENTAL_BUILD_FILE=../rt-closed/closed-build.gradle</arg>
      </task-args>
      <task-jvm-args/>
    </task>
  </common-tasks>

 */

task netBeans() {
    description = "Creates the NetBeans project files for JavaFX"
    group = "IDE"

    doLast {
        File nbGradleProperties = file(".nb-gradle-properties")
        if (nbGradleProperties.exists()) nbGradleProperties.delete()
        nbGradleProperties.createNewFile()
        nbGradleProperties <<
"""<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<gradle-project-properties>
  <!--DO NOT EDIT THIS FILE! - Used by the Gradle plugin of NetBeans.-->
  <source-encoding>UTF-8</source-encoding>
  <target-platform-name>j2se</target-platform-name>
  <target-platform>1.7</target-platform>
  <source-level>1.7</source-level>
  <script-platform>
    <spec-name>j2se</spec-name>
    <spec-version>1.7</spec-version>
  </script-platform>
  <gradle-home>?VER=1.4</gradle-home>
  <license-header>
    <name>OpenJFX</name>
    <template>.nb-openjfx-template-license</template>
    <property name="organization">OpenJFX</property>
  </license-header>
</gradle-project-properties>"""

        File nbGradleTemplate = file(".nb-openjfx-template-license")
        if (nbGradleTemplate.exists()) nbGradleTemplate.delete()
        nbGradleTemplate.createNewFile()
        nbGradleTemplate <<
"""My License will reign supreme!"""
    }
}

task cleanNetBeans() {
    description = "Deletes generated NetBeans files"
    group = "IDE"
    doLast {
        file(".nb-gradle-properties").delete()
    }
}

/******************************************************************************
 *                                                                            *
 *                   Generation of IDEA Project Files                         *
 *                                                                            *
 *  This next section is responsible for setting up the work for generation   *
 *  of IntelliJ IDEA project files. The developer needs to invoke             *
 *                                                                            *
 *      gradle idea                                                           *
 *                                                                            *
 *  and all necessary project files will be generated.                        *
 *                                                                            *
 *****************************************************************************/

allprojects {
    apply plugin: 'idea'
    if (project == rootProject || project.name == "media" || project.name == "web") return

    // Configure all projects to include $buildDir/generated-src/builders in the generated IDEA project files.
    // Also need to un-exclude the build-dir since we put stuff in it, and then re-exclude other stuff
    if (rootProject.BINARY_STUB != null) {
        configurations {
          binaryStub
          binaryStub.extendsFrom(compile)
        }

        dependencies {
          binaryStub rootProject.BINARY_STUB
        }
    }

    idea {
        module {
            inheritOutputDirs = true;
            sourceDirs += file("$buildDir/generated-src/builders");
            excludeDirs -= buildDir;
            excludeDirs += [
                    new File(buildDir, "classes"),
                    new File(buildDir, "dependency-cache"),
                    new File(buildDir, "libs"),
                    new File(buildDir, "resources"),
                    new File(buildDir, "tmp")];

            if (rootProject.BINARY_STUB != null) {
                scopes.COMPILE.plus += configurations.binaryStub

                // Some hackery. I have to make sure the binary stub is the VERY LAST entry
                // in the class path or things will be somewhat unpredictable
                iml {
                    withXml { xmlProvider ->
                        def root = xmlProvider.asNode();
                        // Find the <root url=".../jfxrt.jar!/" />. Walk up 3 steps to <orderEntry>
                        def orderEntry = root.depthFirst().find { it.name() == "root" }.parent().parent().parent(); // && it.@url.contains(rootProject.files(rootProject.BINARY_STUB))
                        if (orderEntry.name() != "orderEntry") throw new Exception("Couldn't find the order entry");
                        // Move that <orderEntry> to be the last child of its parent.
                        def parent = orderEntry.parent();
                        parent.remove(orderEntry);
                        parent.append(orderEntry);
                    }
                }
            }
        }
    }
}

/**
 * I want to keep all the project files and out directory and such all hidden from the filesystem
 * for the most part, so we don't have a lot of .iml files strewn about. So what we will do is
 * to redirect all of the .iml files into a .idea directory on the root project level, and stash the
 * out/ for all the projects there as well as the project module definition files.
 */
idea {
    project {
        jdkName = "JavaFX 1.7"
        languageLevel = "1.7"
        wildcards += ["?*.css", "?*.bss", "?*.glsl", "?*.frag", "?*.ttf", "?*.txt", "?*.fxml"]
        ipr {
            withXml { xmlProvider ->
                def root = xmlProvider.asNode();
                def doc = root.depthFirst();

                // Set the copyright
                def copyrightManager = doc.find { it.name() == "component" && it.@name == "CopyrightManager" };
                copyrightManager.@default="OpenJFX";
                def module2copyright = copyrightManager.get("module2copyright");
                module2copyright.replaceNode {
                    copyright {
                        option(name: "notice", value:
"""Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.

This code is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License version 2 only, as
published by the Free Software Foundation.  Oracle designates this
particular file as subject to the "Classpath" exception as provided
by Oracle in the LICENSE file that accompanied this code.

This code is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
version 2 for more details (a copy is included in the LICENSE file that
accompanied this code).

You should have received a copy of the GNU General Public License version
2 along with this work; if not, write to the Free Software Foundation,
Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.

Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
or visit www.oracle.com if you need additional information or have any
questions.""");
                        option(name: "keyword", value: "Copyright");
                        option(name: "allowReplaceKeyword", value: "");
                        option(name: "myName", value: "OpenJFX");
                        option(name: "myLocal", value: "true");
                    }
                }

                // Remove some setting and change the project output directory
                def projectRootManager = doc.find { it.name() == "component" && it.@name == "ProjectRootManager" };
                projectRootManager.attributes.remove("assert-jdk-15");
                projectRootManager.children()[0].@url = "file://\$PROJECT_DIR\$/.idea-out";

                // Add in some custom dictionary stuff so that people get fewer green-squigglies
                // in their code. Nothing like a green squiggly to ruin my day.
                copyrightManager.plus {
                    component(name: "ProjectDictionaryState") {
                        dictionary(name: "javafx") {
                            words {
                                w (text: "backoff")
                                w (text: "blhr")
                                w (text: "blvr")
                                w (text: "brhr")
                                w (text: "brvr")
                                w (text: "gradle")
                                w (text: "gzip")
                                w (text: "halignment")
                                w (text: "interpolator")
                                w (text: "jfxrt")
                                w (text: "multithreaded")
                                w (text: "redoable")
                                w (text: "resized")
                                w (text: "squigglies")
                                w (text: "subclassing")
                                w (text: "timeline")
                                w (text: "timeline's")
                                w (text: "tlhr")
                                w (text: "tlvr")
                                w (text: "trhr")
                                w (text: "trvr")
                                w (text: "unmanaged")
                                w (text: "unselect")
                                w (text: "urlencoded")
                                w (text: "valignment")
                            }
                        }
                    }
                }

                // Setup some common project settings like tabs vs. spaces
                copyrightManager.plus {
                    component(name: "CodeStyleSettingsManager") {
                        option(name: "PER_PROJECT_SETTINGS") {
                            value {
                                ADDITIONAL_INDENT_OPTIONS(fileType: "java") {
                                    option (name: "IDENT_SIZE", value: "4")
                                    option (name: "CONTINUATION_INDENT_SIZE", value: "8")
                                    option (name: "TAB_SIZE", value: "4")
                                    option (name: "USE_TAB_CHARACTER", value: "false")
                                    option (name: "SMART_TABS", value: "false")
                                    option (name: "LABEL_INDENT_SIZE", value: "0")
                                    option (name: "LABEL_INDENT_ABSOLUTE", value: "false")
                                    option (name: "USE_RELATIVE_INDENTS", value: "false")
                                }
                                ADDITIONAL_INDENT_OPTIONS(fileType: "xml") {
                                    option (name: "IDENT_SIZE", value: "4")
                                    option (name: "CONTINUATION_INDENT_SIZE", value: "8")
                                    option (name: "TAB_SIZE", value: "4")
                                    option (name: "USE_TAB_CHARACTER", value: "false")
                                    option (name: "SMART_TABS", value: "false")
                                    option (name: "LABEL_INDENT_SIZE", value: "0")
                                    option (name: "LABEL_INDENT_ABSOLUTE", value: "false")
                                    option (name: "USE_RELATIVE_INDENTS", value: "false")
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

//project("buildSrc") {
//    // Add antlr to the sources for IDEA
//    idea {
//        module {
//            sourceDirs += file("$buildDir/generated-src/antlr")
//        }
//    }
//}

project(":base") {
    // Add in the version-info generated sources for IDEA projects
    idea {
        module {
            sourceDirs += file("$buildDir/generated-src/version-info")
        }
    }
}

project(":graphics") {
    idea {
        module {
            sourceDirs += [file("$buildDir/generated-src/headers"),
                    file("src/main/native-decora"),
                    file("src/main/native-glass/gtk"),
                    file("src/main/native-glass/ios"),
                    file("src/main/native-glass/lens"),
                    file("src/main/native-glass/mac"),
                    file("src/main/native-glass/win"),
                    file("src/main/native-prism"),
                    file("src/main/native-prism-sw")]
            // TODO generated JSL directories need to be added
//            sourceDirs += file("$buildDir/generated-src/jsl")
//            sourceDirs += file("$buildDir/generated-src/jsl")
            excludeDirs += new File(buildDir, "native");
            testSourceDirs += [file("src/stub/java"), file("src/stub/resources")];
        }
    }
}

project(":controls") {
    idea {
        module {
            sourceDirs += file("src/main/dt");
        }
    }
}

cleanIdeaWorkspace.group = "IDE"
cleanIdeaWorkspace.description = "Deletes the javafx.ipw file"

/******************************************************************************
 *                                                                            *
 *                         SUPPLEMENTAL_BUILD_FILE                            *
 *                                                                            *
 * This next section should remain at the end of the build script. It allows  *
 * for a "supplemental" gradle file to be used to extend the normal build     *
 * structure. For example, this is used for passing a supplemental gradle     *
 * file for producing official JavaFX builds.                                 *
 *                                                                            *
 *****************************************************************************/

if (hasProperty("SUPPLEMENTAL_BUILD_FILE")) {
    apply from: SUPPLEMENTAL_BUILD_FILE
}
